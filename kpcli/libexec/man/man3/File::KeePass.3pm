.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::KeePass 3"
.TH File::KeePass 3 "2012-09-15" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::KeePass \- Interface to KeePass V1 and V2 database files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use File::KeePass;
\&    use Data::Dumper qw(Dumper);
\&
\&    my $k = File::KeePass\->new;
\&
\&    # read a version 1 or version 2 database
\&    $k\->load_db($file, $master_pass); # errors die
\&
\&    print Dumper $k\->header;
\&    print Dumper $k\->groups; # passwords are locked
\&
\&    $k\->unlock;
\&    print Dumper $k\->groups; # passwords are now visible
\&
\&    $k\->clear; # delete current db from memory
\&
\&
\&    my $group = $k\->add_group({
\&        title => \*(AqFoo\*(Aq,
\&    }); # root level group
\&    my $gid = $group\->{\*(Aqid\*(Aq};
\&
\&    my $group = $k\->find_group({id => $gid});
\&    # OR
\&    my $group = $k\->find_group({title => \*(AqFoo\*(Aq});
\&
\&
\&    my $group2 = $k\->add_group({
\&        title => \*(AqBar\*(Aq,
\&        group => $gid,
\&        # OR group => $group,
\&    }); # nested group
\&
\&
\&    my $e = $k\->add_entry({
\&        title    => \*(AqSomething\*(Aq,
\&        username => \*(Aqsomeuser\*(Aq,
\&        password => \*(Aqsomepass\*(Aq,
\&        group    => $gid,
\&        # OR group => $group,
\&    });
\&    my $eid = $e\->{\*(Aqid\*(Aq};
\&
\&    my $e = $k\->find_entry({id => $eid});
\&    # OR
\&    my $e = $k\->find_entry({title => \*(AqSomething\*(Aq});
\&
\&    $k\->lock;
\&    print $e\->{\*(Aqpassword\*(Aq}; # eq undef
\&    print $k\->locked_entry_password($e); # eq \*(Aqsomepass\*(Aq
\&
\&    $k\->unlock;
\&    print $e\->{\*(Aqpassword\*(Aq}; # eq \*(Aqsomepass\*(Aq
\&
\&
\&    # save out a version 1 database
\&    $k\->save_db("/some/file/location.kdb", $master_pass);
\&
\&    # save out a version 2 database
\&    $k\->save_db("/some/file/location.kdbx", $master_pass);
\&
\&    # save out a version 1 database using a password and key file
\&    $k\->save_db("/some/file/location.kdb", [$master_pass, $key_filename]);
\&
\&
\&    # read database from a file
\&    $k\->parse_db($pass_db_string, $pass);
\&
\&    # generate a keepass version 1 database string
\&    my $pass_db_string = $k\->gen_db($pass);
\&
\&    # generate a keepass version 2 database string
\&    my $pass_db_string = $k\->gen_db($pass);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
File::KeePass gives access to KeePass version 1 (kdb) and version 2
(kdbx) databases.
.PP
The version 1 and version 2 databases are very different in
construction, but the majority of information overlaps and many
algorithms are similar.  File::KeePass attempts to iron out as many of
the differences.
.PP
File::KeePass gives nearly raw data access.  There are a few utility
methods for manipulating groups and entries.  More advanced
manipulation can easily be layered on top by other modules.
.PP
File::KeePass is only used for reading and writing databases and for
keeping passwords scrambled while in memory.  Programs dealing with \s-1UI\s0
or using of auto-type features are the domain of other modules on
\&\s-1CPAN. \s0 File::KeePass::Agent is one example.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
Takes a hashref or hash of arguments.  Returns a new File::KeePass
object.  Any named arguments are added to self.
.IP "load_db" 4
.IX Item "load_db"
Takes a kdb filename, a master password, and an optional argument
hashref.  Returns the File::KeePass object on success (can be called
as a class method).  Errors die.  The resulting database can be
accessed via various methods including \f(CW$k\fR\->groups.
.Sp
.Vb 2
\&    my $k = File::KeePass\->new;
\&    $k\->load_db($file, $pwd);
\&
\&    my $k = File::KeePass\->load_db($file, $pwd);
\&
\&    my $k = File::KeePass\->load_db($file, $pwd, {auto_lock => 0});
.Ve
.Sp
The contents are read from file and passed to parse_db.
.Sp
The password passed to load_db may be a composite key in
any of the following forms:
.Sp
.Vb 6
\&    "password"                   # password only
\&    ["password"]                 # same
\&    ["password", "keyfilename"]  # password and key file
\&    [undef, "keyfilename"]       # key file only
\&    ["password", \e"keycontent"]  # password and reference to key file content
\&    [undef, \e"keycontent"]       # reference to key file content only
.Ve
.Sp
The key file is optional.  It may be passed as a filename, or as a
scalar reference to the contents of the key file.  If a filename is
passed it will be read in.  The key file can contain any of the
following three types:
.Sp
.Vb 3
\&    length 32         # treated as raw key
\&    length 64         # must be 64 hexidecimal characters
\&    any\-other\-length  # a SHA256 sum will be taken of the data
.Ve
.IP "save_db" 4
.IX Item "save_db"
Takes a kdb filename and a master password.  Stores out the current
groups in the object.  Writes attempt to write first to
\&\f(CW$file\fR.new.$epoch and are then renamed into the correct location.
.Sp
You will need to unlock the db via \f(CW$k\fR\->unlock before calling this
method if the database is currently locked.
.Sp
The same master password types passed to load_db can be used here.
.IP "parse_db" 4
.IX Item "parse_db"
Takes a string or a reference to a string containting an encrypted kdb
database, a master password, and an optional argument hashref.
Returns the File::KeePass object on success (can be called as a class
method).  Errors die.  The resulting database can be accessed via
various methods including \f(CW$k\fR\->groups.
.Sp
.Vb 2
\&    my $k = File::KeePass\->new;
\&    $k\->parse_db($loaded_kdb, $pwd);
\&
\&    my $k = File::KeePass\->parse_db($kdb_buffer, $pwd);
\&
\&    my $k = File::KeePass\->parse_db($kdb_buffer, $pwd, {auto_lock => 0});
.Ve
.Sp
The same master password types passed to load_db can be used here.
.IP "parse_header" 4
.IX Item "parse_header"
Used by parse_db.  Reads just the header information.  Can be used as
a basic KeePass file check.  The returned hash will contain version =>
1 or version => 2 depending upon which type of header is found.  Can
be called as a class method.
.Sp
.Vb 2
\&    my $head = File::KeePass\->parse_header($kdb_buffer); # errors die
\&    printf "This is a version %d database\en", $head\->{\*(Aqversion\*(Aq};
.Ve
.IP "gen_db" 4
.IX Item "gen_db"
Takes a master password.  Optionally takes a \*(L"groups\*(R" arrayref and a
\&\*(L"headers\*(R" hashref.  If groups are not passed, it defaults to using the
currently loaded groups.  If headers are not passed, a fresh set of
headers are generated based on the groups and the master password.
The headers can be passed in to test round trip portability.
.Sp
You will need to unlock the db via \f(CW$k\fR\->unlock before calling this
method if the database is currently locked.
.Sp
The same master password types passed to load_db can be used here.
.IP "header" 4
.IX Item "header"
Returns a hashref representing the combined current header and meta
information for the currently loaded database.
.Sp
The following fields are present in both version 1 and version 2
style databases (from the header):
.Sp
.Vb 10
\&    enc_iv               => "123456789123456", # rand
\&    enc_type             => "rijndael",
\&    header_size          => 222,
\&    seed_key             => "1234567890123456", # rand (32 bytes on v2)
\&    seed_rand            => "12345678901234567890123456789012", # rand
\&    rounds               => 6000,
\&    sig1                 => "2594363651",
\&    sig2                 => "3041655655", # indicates db version
\&    ver                  => 196608,
\&    version              => 1, # or 2
.Ve
.Sp
The following keys will be present after the reading of a version 2
database (from the header):
.Sp
.Vb 5
\&    cipher               => "aes",
\&    compression          => 1,
\&    protected_stream     => "salsa20",
\&    protected_stream_key => "12345678901234567890123456789012", # rand
\&    start_bytes          => "12345678901234567890123456789012", # rand
.Ve
.Sp
Additionally, items parsed from the Meta section of a version 2
database will be added.  The following are the available fields.
.Sp
.Vb 10
\&    color                         => "#4FFF00",
\&    custom_data                   => {key1 => "val1"},
\&    database_description          => "database desc",
\&    database_description_changed  => "2012\-08\-17 00:30:56",
\&    database_name                 => "database name",
\&    database_name_changed         => "2012\-08\-17 00:30:56",
\&    default_user_name             => "",
\&    default_user_name_changed     => "2012\-08\-17 00:30:34",
\&    entry_templates_group         => "VL5nOpzlFUevGhqL71/OTA==",
\&    entry_templates_group_changed => "2012\-08\-21 14:05:32",
\&    generator                     => "KeePass",
\&    history_max_items             => 10,
\&    history_max_size              => 6291456, # bytes
\&    last_selected_group           => "SUgL30QQqUK3tOWuNKUYJA==",
\&    last_top_visible_group        => "dC1sQ1NO80W7klmRhfEUVw==",
\&    maintenance_history_days      => 365,
\&    master_key_change_force       => \-1,
\&    master_key_change_rec         => \-1,
\&    master_key_changed            => "2012\-08\-17 00:30:34",
\&    protect_notes                 => 0,
\&    protect_password              => 1,
\&    protect_title                 => 0,
\&    protect_url                   => 0,
\&    protect_username              => 0
\&    recycle_bin_changed           => "2012\-08\-17 00:30:34",
\&    recycle_bin_enabled           => 1,
\&    recycle_bin_uuid              => "SUgL30QQqUK3tOWuNKUYJA=="
.Ve
.Sp
When writing a database via either save_db or gen_db, these
fields can be set and passed along.  Optionally, it is possible
to pass along a key called reuse_header to let calls to save_db
and gen_db automatically use the contents of the previous header.
.IP "clear" 4
.IX Item "clear"
Clears any currently loaded database.
.IP "auto_lock" 4
.IX Item "auto_lock"
Default true.  If true, passwords are automatically hidden when a
database loaded via parse_db or load_db.
.Sp
.Vb 1
\&    $k\->auto_lock(0); # turn off auto locking
.Ve
.IP "is_locked" 4
.IX Item "is_locked"
Returns true if the current database is locked.
.IP "lock" 4
.IX Item "lock"
Locks the database.  This moves all passwords into a protected, in
memory, encrypted storage location.  Returns 1 on success.  Returns 2
if the db is already locked.  If a database is loaded via parse_db or
load_db and auto_lock is true, the newly loaded database will start
out locked.
.IP "unlock" 4
.IX Item "unlock"
Unlocks a previously locked database.  You will need to unlock a
database before calling save_db or gen_db.
.SH "GROUP/ENTRY METHODS"
.IX Header "GROUP/ENTRY METHODS"
.IP "dump_groups" 4
.IX Item "dump_groups"
Returns a simplified string representation of the currently loaded
database.
.Sp
.Vb 1
\&    print $k\->dump_groups;
.Ve
.Sp
You can optionally pass a match argument hashref.  Only entries
matching the criteria will be returned.
.IP "groups" 4
.IX Item "groups"
Returns an arrayref of groups from the currently loaded database.
Groups returned will be hierarchal.  Note, groups simply returns a
reference to all of the data.  It makes no attempts at cleaning up the
data (find_groups will make sure the data is groomed).
.Sp
.Vb 1
\&    my $g = $k\->groups;
.Ve
.Sp
Groups will look similar to the following:
.Sp
.Vb 10
\&    $g = [{
\&         expanded => 0,
\&         icon     => 0,
\&         id       => 234234234, # under v1 this is a 32 bit int, under v2 it is a 16 char id
\&         title    => \*(AqFoo\*(Aq,
\&         level    => 0,
\&         entries => [{
\&             accessed => "2010\-06\-24 15:09:19",
\&             comment  => "",
\&             created  => "2010\-06\-24 15:09:19",
\&             expires  => "2999\-12\-31 23:23:59",
\&             icon     => 0,
\&             modified => "2010\-06\-24 15:09:19",
\&             title    => "Something",
\&             password => \*(Aqsomepass\*(Aq, # will be hidden if the database is locked
\&             url      => "",
\&             username => "someuser",
\&             id       => "0a55ac30af68149f", # v1 is any hex char, v2 is any 16 char
\&         }],
\&         groups => [{
\&             expanded => 0,
\&             icon     => 0,
\&             id       => 994414667,
\&             level    => 1,
\&             title    => "Bar"
\&         }],
\&     }];
.Ve
.IP "add_group" 4
.IX Item "add_group"
Adds a new group to the database.  Returns a reference to the new
group.  If a database isn't loaded, it begins a new one.  Takes a
hashref of arguments for the new entry including title, icon,
expanded.  A new random group id will be generated.  An optional group
argument can be passed.  If a group is passed the new group will be
added under that parent group.
.Sp
.Vb 2
\&    my $group = $k\->add_group({title => \*(AqFoo\*(Aq});
\&    my $gid = $group\->{\*(Aqid\*(Aq};
\&
\&    my $group2 = $k\->add_group({title => \*(AqBar\*(Aq, group => $gid});
.Ve
.Sp
The group argument's value may also be a reference to a group \- such as
that returned by find_group.
.IP "finder_tests {" 4
.IX Item "finder_tests {"
Used by find_groups and find_entries.  Takes a hashref of arguments
and returns a list of test code refs.
.Sp
.Vb 4
\&    {title => \*(AqFoo\*(Aq} # will check if title equals Foo
\&    {\*(Aqtitle !\*(Aq => \*(AqFoo\*(Aq} # will check if title does not equal Foo
\&    {\*(Aqtitle =~\*(Aq => qr{^Foo$}} # will check if title does matches the regex
\&    {\*(Aqtitle !~\*(Aq => qr{^Foo$}} # will check if title does not match the regex
.Ve
.IP "find_groups" 4
.IX Item "find_groups"
Takes a hashref of search criteria and returns all matching groups.
Can be passed id, title, icon, and level.  Search arguments will be
parsed by finder_tests.
.Sp
.Vb 1
\&    my @groups = $k\->find_groups({title => \*(AqFoo\*(Aq});
\&
\&    my @all_groups_flattened = $k\->find_groups({});
.Ve
.Sp
The find_groups method also checks to make sure group ids are unique
and that all needed values are defined.
.IP "find_group" 4
.IX Item "find_group"
Calls find_groups and returns the first group found.  Dies if multiple
results are found.  In scalar context it returns only the group.  In
list context it returns the group, and its the arrayref in which it is
stored (either the root level group or a sub groups group item).
.IP "delete_group" 4
.IX Item "delete_group"
Passes arguments to find_group to find the group to delete.  Then
deletes the group.  Returns the group that was just deleted.
.IP "add_entry" 4
.IX Item "add_entry"
Adds a new entry to the database.  Returns a reference to the new
entry.  An optional group argument can be passed.  If a group is not
passed, the entry will be added to the first group in the database.  A
new entry id will be created if one is not passed or if it conflicts
with an existing group.
.Sp
The following fields can be passed to both v1 and v2 databases.
.Sp
.Vb 10
\&    accessed => "2010\-06\-24 15:09:19", # last accessed date
\&    auto_type => [{keys => "{USERNAME}{TAB}{PASSWORD}{ENTER}", window => "Foo*"}],
\&    binary   => {foo => \*(Aqcontent\*(Aq}; # hashref of filename/content pairs
\&    comment  => "", # a comment for the system \- auto\-type info is normally here
\&    created  => "2010\-06\-24 15:09:19", # entry creation date
\&    expires  => "2999\-12\-31 23:23:59", # date entry expires
\&    icon     => 0, # icon number for use with agents
\&    modified => "2010\-06\-24 15:09:19", # last modified
\&    title    => "Something",
\&    password => \*(Aqsomepass\*(Aq, # will be hidden if the database is locked
\&    url      => "http://",
\&    username => "someuser",
\&    id       => "0a55ac30af68149f", # auto generated if needed, v1 is any hex char, v2 is any 16 char
\&    group    => $gid, # which group to add the entry to
.Ve
.Sp
For compatibility with earlier versions of File::KeePass, it is
possible to pass in a binary and binary_name when creating an entry.
They will be automatically converted to the hashref of
filename/content pairs
.Sp
.Vb 2
\&    binary_name => "foo", # description of the stored binary \- typically a filename
\&    binary   => "content", # raw data to be stored in the system \- typically a file
\&
\&    # results in
\&    binary => {"foo" => "content"}
.Ve
.Sp
Typically, version 1 databases store their Auto-Type information
inside of the comment.  They are also limited to having only one key
sequence per entry.  File::KeePass 2+ will automatically parse
Auto-Type values passed in the entry comment and store them out as the
auto_type arrayref.  This arrayref is serialized back into the comment
section when saving as a version 1 database.  Version 2 databases have
a separate storage mechanism for Auto-Type.
.Sp
.Vb 6
\&    If you passed in:
\&    comment => "
\&       Auto\-Type: {USERNAME}{TAB}{PASSWORD}{ENTER}
\&       Auto\-Type\-Window: Foo*
\&       Auto\-Type\-Window: Bar*
\&    ",
\&
\&    Will result in:
\&    auto_type => [{
\&        keys => "{USERNAME}{TAB}{PASSWORD}{ENTER}",
\&        window => "Foo*"
\&     }, {
\&        keys => "{USERNAME}{TAB}{PASSWORD}{ENTER}",
\&        window => "Bar*"
\&     }],
.Ve
.Sp
The group argument value may be either an existing group id, or a
reference to a group \- such as that returned by find_group.
.Sp
When using a version 2 database, the following additional fields are
also available:
.Sp
.Vb 10
\&    expires_enabled   => 0,
\&    location_changed  => "2012\-08\-05 12:12:12",
\&    usage_count       => 0,
\&    tags              => {},
\&    background_color  => \*(Aq#ff0000\*(Aq,
\&    foreground_color  => \*(Aq#ffffff\*(Aq,
\&    custom_icon_uuid  => \*(Aq234242342aa\*(Aq,
\&    history           => [], # arrayref of previous entry changes
\&    override_url      => $node\->{\*(AqOverrideURL\*(Aq},
\&    auto_type_enabled => 1,
\&    auto_type_munge   => 0, # whether or not to attempt two channel auto typing
\&    protected         => {password => 1}, # indicating which strings were/should be salsa20 protected
\&    strings           => {\*(Aqother key\*(Aq => \*(Aqother value\*(Aq},
.Ve
.IP "find_entries" 4
.IX Item "find_entries"
Takes a hashref of search criteria and returns all matching groups.
Can be passed an entry id, title, username, comment, url, active,
group_id, group_title, or any other entry property.  Search arguments
will be parsed by finder_tests.
.Sp
.Vb 1
\&    my @entries = $k\->find_entries({title => \*(AqSomething\*(Aq});
\&
\&    my @all_entries_flattened = $k\->find_entries({});
.Ve
.IP "find_entry" 4
.IX Item "find_entry"
Calls find_entries and returns the first entry found.  Dies if
multiple results are found.  In scalar context it returns only the
entry.  In list context it returns the entry, and its group.
.IP "delete_entry" 4
.IX Item "delete_entry"
Passes arguments to find_entry to find the entry to delete.  Then
deletes the entry.  Returns the entry that was just deleted.
.IP "locked_entry_password" 4
.IX Item "locked_entry_password"
Allows access to individual passwords for a database that is locked.
Dies if the database is not locked.
.SH "UTILITY METHODS"
.IX Header "UTILITY METHODS"
The following methods are general purpose methods used during the
parsing and generating of kdb databases.
.IP "now" 4
.IX Item "now"
Returns the current localtime datetime stamp.
.IP "default_exp" 4
.IX Item "default_exp"
Returns the string representing the default expires time of an entry.
Will use \f(CW$self\fR\->{'default_exp'} or fails to the string '2999\-12\-31
23:23:59'.
.IP "decrypt_rijndael_cbc" 4
.IX Item "decrypt_rijndael_cbc"
Takes an encrypted string, a key, and an encryption_iv string.
Returns a plaintext string.
.IP "encrypt_rijndael_cbc" 4
.IX Item "encrypt_rijndael_cbc"
Takes a plaintext string, a key, and an encryption_iv string.  Returns
an encrypted string.
.IP "decode_base64" 4
.IX Item "decode_base64"
Loads the MIME::Base64 library and decodes the passed string.
.IP "encode_base64" 4
.IX Item "encode_base64"
Loads the MIME::Base64 library and encodes the passed string.
.IP "unchunksum" 4
.IX Item "unchunksum"
Parses and reassembles a buffer, reading in lengths, and checksums
of chunks.
.IP "decompress" 4
.IX Item "decompress"
Loads the Compress::Raw::Zlib library and inflates the contents.
.IP "compress" 4
.IX Item "compress"
Loads the Compress::Raw::Zlib library and deflates the contents.
.IP "parse_xml" 4
.IX Item "parse_xml"
Loads the XML::Parser library and sets up a basic parser that can call
hooks at various events.  Without the hooks, it runs similarly to
XML::Simple::parse.
.Sp
.Vb 6
\&    my $data = $self\->parse_xml($buffer, {
\&        top            => \*(AqKeePassFile\*(Aq,
\&        force_array    => {Group => 1, Entry => 1},
\&        start_handlers => {Group => sub { $level++ }},
\&        end_handlers   => {Group => sub { $level\-\- }},
\&    });
.Ve
.IP "gen_xml" 4
.IX Item "gen_xml"
Generates \s-1XML\s0 from the passed data structure.  The output of parse_xml
can be passed as is.  Additionally hints such as _\|_sort_\|_ can be used
to order the tags of a node and _\|_attr_\|_ can be used to indicate which
items of a node are attributes.
.IP "salsa20" 4
.IX Item "salsa20"
Takes a hashref containing a salsa20 key string (length 32 or 16), a
salsa20 iv string (length 8), number of salsa20 rounds (8, 12, or 20 \-
default 20), and an optional data string.  The key and iv are used to
initialize the salsa20 encryption.
.Sp
If a data string is passed, the string is salsa20 encrypted and
returned.
.Sp
If no data string is passed a salsa20 encrypting coderef is returned.
.Sp
.Vb 3
\&    my $encoded = $self\->salsa20({key => $key, iv => $iv, data => $data});
\&    my $uncoded = $self\->salsa20({key => $key, iv => $iv, data => $encoded});
\&    # $data eq $uncoded
\&
\&    my $encoder = $self\->salsa20({key => $key, iv => $Iv}); # no data
\&    my $encoded = $encoder\->($data);
\&    my $part2   = $encoder\->($more_data); # continues from previous state
.Ve
.IP "salsa20_stream" 4
.IX Item "salsa20_stream"
Takes a hashref that will be passed to salsa20.  Uses the resulting
encoder to generate a more continuous encoded stream.  The salsa20
method encodes in chunks of 64 bytes.  If a string is not a multiple
of 64, then some of the xor bytes are unused.  The salsa20_stream
method maintains a buffer of xor bytes to ensure that none are wasted.
.Sp
.Vb 3
\&    my $encoder = $self\->salsa20_stream({key => $key, iv => $Iv}); # no data
\&    my $encoded = $encoder\->("1234");   # calls salsa20\->()
\&    my $part2   = $encoder\->("1234");   # uses the same pad until 64 bytes are used
.Ve
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.IP "_parse_v1_header" 4
.IX Item "_parse_v1_header"
.PD 0
.IP "_parse_v1_body" 4
.IX Item "_parse_v1_body"
.IP "_parse_v1_groups" 4
.IX Item "_parse_v1_groups"
.IP "_parse_v1_entries" 4
.IX Item "_parse_v1_entries"
.IP "_parse_v1_date" 4
.IX Item "_parse_v1_date"
.PD
Utilities used for parsing version 1 type databases.
.IP "_parse_v2_header" 4
.IX Item "_parse_v2_header"
.PD 0
.IP "_parse_v2_body" 4
.IX Item "_parse_v2_body"
.IP "_parse_v2_date" 4
.IX Item "_parse_v2_date"
.PD
Utilities used for parsing version 2 type databases.
.IP "_gen_v1_db" 4
.IX Item "_gen_v1_db"
.PD 0
.IP "_gen_v1_header" 4
.IX Item "_gen_v1_header"
.IP "_gen_v1_date" 4
.IX Item "_gen_v1_date"
.PD
Utilities used to generate version 1 type databases.
.IP "_gen_v2_db" 4
.IX Item "_gen_v2_db"
.PD 0
.IP "_gen_v2_header" 4
.IX Item "_gen_v2_header"
.IP "_gen_v2_date" 4
.IX Item "_gen_v2_date"
.PD
Utilities used to generate version 2 type databases.
.IP "_master_key" 4
.IX Item "_master_key"
Takes the password and parsed headers.  Returns the
master key based on database type.
.SH "ONE LINERS"
.IX Header "ONE LINERS"
(Long one liners)
.PP
Here is a version 1 to version 2, or version 2 to version 1 converter.
Simply change the extension of the two files.  Someday we will include
a kdb2kdbx utility to do this for you.
.PP
.Vb 1
\&    perl \-MFile::KeePass \-e \*(Aquse IO::Prompt; $p="".prompt("Pass:",\-e=>"*",\-tty); File::KeePass\->load_db(+shift,$p,{auto_lock=>0})\->save_db(+shift,$p)\*(Aq ~/test.kdb ~/test.kdbx
\&
\&    # OR using graphical prompt
\&    perl \-MFile::KeePass \-e \*(Aqchop($p=\`zenity \-\-password\`); File::KeePass\->load_db(+shift,$p,{auto_lock=>0})\->save_db(+shift,$p)\*(Aq ~/test.kdbx ~/test.kdb
\&
\&    # OR using pure perl (but echoes password)
\&    perl \-MFile::KeePass \-e \*(Aqprint "Pass:"; chop($p=<STDIN>); File::KeePass\->load_db(+shift,$p,{auto_lock=>0})\->save_db(+shift,$p)\*(Aq ~/test.kdbx ~/test.kdb
.Ve
.PP
Dumping the \s-1XML\s0 from a version 2 database.
.PP
.Vb 1
\&    perl \-MFile::KeePass \-e \*(Aqchop($p=\`zenity \-\-password\`); print File::KeePass\->load_db(+shift,$p,{keep_xml=>1})\->{xml_in},"\en"\*(Aq ~/test.kdbx
.Ve
.PP
Outlining group information.
.PP
.Vb 1
\&    perl \-MFile::KeePass \-e \*(Aqchop($p=\`zenity \-\-password\`); print File::KeePass\->load_db(+shift,$p)\->dump_groups\*(Aq ~/test.kdbx
.Ve
.PP
Dumping header information
.PP
.Vb 1
\&    perl \-MFile::KeePass \-MData::Dumper \-e \*(Aqchop($p=\`zenity \-\-password\`); print Dumper +File::KeePass\->load_db(+shift,$p)\->header\*(Aq ~/test.kdbx
.Ve
.SH "BUGS"
.IX Header "BUGS"
Only Rijndael is supported when using v1 databases.
.PP
This module makes no attempt to act as a password agent.  That is the
job of File::KeePass::Agent.  This isn't really a bug but some people
will think it is.
.PP
Groups and entries don't have true objects associated with them.  At
the moment this is by design.  The data is kept as plain boring data.
.SH "SOURCES"
.IX Header "SOURCES"
Knowledge about the algorithms necessary to decode a KeePass \s-1DB\s0 v1
format was gleaned from the source code of keepassx\-0.4.3.  That
source code is published under the \s-1GPL2\s0 license.  KeePassX 0.4.3 bears
the copyright of
.PP
.Vb 2
\&    Copyright (C) 2005\-2008 Tarek Saidi <tarek.saidi@arcor.de>
\&    Copyright (C) 2007\-2009 Felix Geyer <debfx\-keepassx {at} fobos.de>
.Ve
.PP
Knowledge about the algorithms necessary to decode a KeePass \s-1DB\s0 v2
format was gleaned from the source code of keepassx\-2.0\-alpha1.  That
source code is published under the \s-1GPL2\s0 or \s-1GPL3\s0 license.  KeePassX
2.0\-alpha1 bears the copyright of
.PP
.Vb 2
\&    Copyright: 2010\-2012, Felix Geyer <debfx@fobos.de>
\&               2011\-2012, Florian Geyer <blueice@fobos.de>
.Ve
.PP
The salsa20 algorithm is based on
http://cr.yp.to/snuffle/salsa20/regs/salsa20.c which is listed as
Public domain (D. J. Bernstein).
.PP
The ordering and layering of encryption/decryption algorithms of
File::KeePass are of derivative nature from KeePassX and could not
have been created without this insight \- though the perl code is from
scratch.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Seamons <paul@seamons.com>
.SH "LICENSE"
.IX Header "LICENSE"
This module may be distributed under the same terms as Perl itself.
