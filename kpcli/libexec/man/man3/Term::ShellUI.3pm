.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ShellUI 3"
.TH Term::ShellUI 3 "2012-02-03" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ShellUI \- A fully\-featured shell\-like command line environment
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Term::ShellUI;
\&  my $term = new Term::ShellUI(
\&      commands => {
\&              "cd" => {
\&                  desc => "Change to directory DIR",
\&                  maxargs => 1, args => sub { shift\->complete_onlydirs(@_); },
\&                  proc => sub { chdir($_[0] || $ENV{HOME} || $ENV{LOGDIR}); },
\&              },
\&              "chdir" => { alias => \*(Aqcd\*(Aq },
\&              "pwd" => {
\&                  desc => "Print the current working directory",
\&                  maxargs => 0, proc => sub { system(\*(Aqpwd\*(Aq); },
\&              },
\&              "quit" => {
\&                  desc => "Quit this program", maxargs => 0,
\&                  method => sub { shift\->exit_requested(1); },
\&              }},
\&          history_file => \*(Aq~/.shellui\-synopsis\-history\*(Aq,
\&      );
\&  print \*(AqUsing \*(Aq.$term\->{term}\->ReadLine."\en";
\&  $term\->run();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::ShellUI uses the history and autocompletion features of Term::ReadLine
to present a sophisticated command-line interface to the user.  It tries to
make every feature that one would expect to see in a fully interactive shell
trivial to implement.
You simply declare your command set and let ShellUI take
care of the heavy lifting.
.PP
This module was previously called Term::GDBUI.
.SH "COMMAND SET"
.IX Header "COMMAND SET"
A command set is the data structure that
describes your application's entire user interface.
It's easiest to illustrate with a working example.
We shall implement the following 6 \*(L"\s-1COMMAND\*(R"\s0s:
.IP "help" 4
.IX Item "help"
Prints the help for the given command.
With no arguments, prints a list and short summary of all available commands.
.IP "h" 4
.IX Item "h"
This is just a synonym for \*(L"help\*(R".  We don't want to list it in the
possible completions.
Of course, pressing \*(L"h<tab><return>\*(R" will autocomplete to \*(L"help\*(R" and
then execute the help command.  Including this command allows you to
simply type \*(L"h<return>\*(R".
.Sp
The 'alias' directive used to be called 'syn' (for synonym).
Either term works.
.IP "exists" 4
.IX Item "exists"
This command shows how to use the
\&\*(L"complete_files\*(R"
routines to complete on file names,
and how to provide more comprehensive help.
.IP "show" 4
.IX Item "show"
Demonstrates subcommands (like \s-1GDB\s0's show command).
This makes it easy to implement commands like \*(L"show warranty\*(R"
and \*(L"show args\*(R".
.IP "show args" 4
.IX Item "show args"
This shows more advanced argument processing.
First, it uses cusom argument completion: a static completion for the
first argument (either \*(L"create\*(R" or \*(L"delete\*(R") and the standard
file completion for the second.  When executed, it echoes its own command
name followed by its arguments.
.IP "quit" 4
.IX Item "quit"
How to nicely quit.
Term::ShellUI also follows Term::ReadLine's default of quitting
when Control-D is pressed.
.PP
This code is fairly comprehensive because it attempts to
demonstrate most of Term::ShellUI's many features.  You can find a working
version of this exact code titled \*(L"synopsis\*(R" in the examples directory.
For a more real-world example, see the fileman-example in the same
directory.
.PP
.Vb 10
\& sub get_commands
\& {
\&     return {
\&         "help" => {
\&             desc => "Print helpful information",
\&             args => sub { shift\->help_args(undef, @_); },
\&             method => sub { shift\->help_call(undef, @_); }
\&         },
\&         "h" =>      { alias => "help", exclude_from_completion=>1},
\&         "exists" => {
\&             desc => "List whether files exist",
\&             args => sub { shift\->complete_files(@_); },
\&             proc => sub {
\&                 print "exists: " .
\&                     join(", ", map {\-e($_) ? "<$_>":$_} @_) .
\&                     "\en";
\&             },
\&             doc => <<EOL,
\& Comprehensive documentation for our ls command.
\& If a file exists, it is printed in <angle brackets>.
\& The help can\enspan\enmany\enlines
\& EOL
\&         },
\&         "show" => {
\&             desc => "An example of using subcommands",
\&             cmds => {
\&                 "warranty" => { proc => "You have no warranty!\en" },
\&                 "args" => {
\&                     minargs => 2, maxargs => 2,
\&                     args => [ sub {qw(create delete)},
\&                               \e&Term::ShellUI::complete_files ],
\&                     desc => "Demonstrate method calling",
\&                     method => sub {
\&                         my $self = shift;
\&                         my $parms = shift;
\&                         print $self\->get_cname($parms\->{cname}) .
\&                             ": " . join(" ",@_), "\en";
\&                     },
\&                 },
\&             },
\&         },
\&         "quit" => {
\&             desc => "Quit using Fileman",
\&             maxargs => 0,
\&             method => sub { shift\->exit_requested(1); }
\&         },
\&         "q" => { alias => \*(Aqquit\*(Aq, exclude_from_completion => 1 },
\&     };
\& }
.Ve
.SH "COMMAND"
.IX Header "COMMAND"
This data structure describes a single command implemented
by your application.
\&\*(L"help\*(R", \*(L"exit\*(R", etc.
All fields are optional.
Commands are passed to Term::ShellUI using a \*(L"\s-1COMMAND SET\*(R"\s0.
.IP "desc" 4
.IX Item "desc"
A short, one-line description for the command.  Normally this is
a simple string, but it may also be a subroutine that
will be called every time the description is printed.
The subroutine takes two arguments, \f(CW$self\fR (the Term::ShellUI object),
and \f(CW$cmd\fR (the command hash for the command), and returns the
command's description as a string.
.IP "doc" 4
.IX Item "doc"
A comprehensive, many-line description for the command.
Like desc, this is normally a string but
if you store a reference to a subroutine in this field,
it will be called to calculate the documentation.
Your subroutine should accept three arguments: self (the Term::ShellUI object),
cmd (the command hash for the command), and the command's name.
It should return a string containing the command's documentation.
See examples/xmlexer to see how to read the doc
for a command out of the pod.
.IP "minargs" 4
.IX Item "minargs"
.PD 0
.IP "maxargs" 4
.IX Item "maxargs"
.PD
These set the minimum and maximum number of arguments that this
command will accept.
.IP "proc" 4
.IX Item "proc"
This contains a reference to the subroutine that should be executed
when this command is called.  Arguments are those passed on the
command line and the return value is the value returned by
call_cmd and process_a_cmd (i.e. it is ignored unless your
application makes use of it).
.Sp
If this field is a string instead of a subroutine ref, the string
is printed when the command is executed (good for things like
\&\*(L"Not implemented yet\*(R").
Examples of both subroutine and string procs can be seen in the example
above.
.IP "method" 4
.IX Item "method"
Similar to proc, but passes more arguments.  Where proc simply passes
the arguments for the command, method also passes the Term::ShellUI object
and the command's parms object (see \*(L"call_cmd\*(R"
for more on parms).  Most commands can be implemented entirely using
a simple proc procedure, but sometimes they require addtional information
supplied to the method.  Like proc, method may also be a string.
.IP "args" 4
.IX Item "args"
This tells how to complete the command's arguments.  It is usually
a subroutine.  See \*(L"complete_files\*(R" for an reasonably simple
example, and the \*(L"complete\*(R" routine for a description of the
arguments and cmpl data structure.
.Sp
Args can also be an arrayref.  Each position in the array will be
used as the corresponding argument.
See \*(L"show args\*(R" in get_commands above for an example.
The last argument is repeated indefinitely (see \*(L"maxargs\*(R"
for how to limit this).
.Sp
Finally, args can also be a string.  The string is intended to
be a reminder and is printed whenever the user types tab twice
(i.e. \*(L"a number between 0 and 65536\*(R").
It does not affect completion at all.
.IP "cmds" 4
.IX Item "cmds"
Command sets can be recursive.  This allows a command to have
subcommands (like \s-1GDB\s0's info and show commands, and the
show command in the example above).
A command that has subcommands should only have two fields:
cmds (of course), and desc (briefly describe this collection of subcommands).
It may also implement doc, but ShellUI's default behavior of printing
a summary of the command's subcommands is usually sufficient.
Any other fields (args, method, maxargs, etc) will be taken from
the subcommand.
.IP "exclude_from_completion" 4
.IX Item "exclude_from_completion"
If this field exists, then the command will be excluded from command-line
completion.  This is useful for one-letter abbreviations, such as
\&\*(L"h\*(R"\->\*(L"help\*(R": including \*(L"h\*(R" in the completions just clutters up
the screen.
.IP "exclude_from_history" 4
.IX Item "exclude_from_history"
If this field exists, the command will never be stored in history.
This is useful for commands like help and quit.
.SS "Default Command"
.IX Subsection "Default Command"
If your command set includes a command named '' (the empty
string), this pseudo-command will be called any time the actual
command cannot be found.  Here's an example:
.PP
.Vb 5
\&  \*(Aq\*(Aq => {
\&    proc => "HA ha.  No command here by that name\en",
\&    desc => "HA ha.  No help for unknown commands.",
\&    doc => "Yet more taunting...\en",
\&  },
.Ve
.PP
Note that minargs and maxargs for the default command are ignored.
method and proc will be called no matter how many arguments the user
entered.
.SH "CATEGORIES"
.IX Header "CATEGORIES"
Normally, when the user types 'help', she receives a short
summary of all the commands in the command set.
However, if your application has 30 or more commands, this can
result in information overload.  To manage this, you can organize
your commands into help categories
.PP
All help categories are assembled into a hash and passed to the
the default help_call and
\&\*(L"help_args\*(R" methods.  If you don't
want to use help categories, simply pass undef for the categories.
.PP
Here is an example of how to declare a collection of help categories:
.PP
.Vb 10
\&  my $helpcats = {
\&      breakpoints => {
\&          desc => "Commands to halt the program",
\&          cmds => qw(break tbreak delete disable enable),
\&      },
\&      data => {
\&          desc => "Commands to examine data",
\&          cmds => [\*(Aqinfo\*(Aq, \*(Aqshow warranty\*(Aq, \*(Aqshow args\*(Aq],
\&      }
\&  };
.Ve
.PP
\&\*(L"show warranty\*(R" and \*(L"show args\*(R" on the last line above
are examples of how to include
subcommands in a help category: separate the command and
subcommands with whitespace.
.SH "CALLBACKS"
.IX Header "CALLBACKS"
Callbacks are functions supplied by ShellUI but intended to be called by
your application.
They implement common functions like 'help' and 'history'.
.IP "help_call(cats, parms, topic)" 4
.IX Item "help_call(cats, parms, topic)"
Call this routine to implement your help routine.  Pass
the help categories or undef, followed by the command-line
arguments:
.Sp
.Vb 3
\&  "help" =>   { desc => "Print helpful information",
\&                args => sub { shift\->help_args($helpcats, @_); },
\&                method => sub { shift\->help_call($helpcats, @_); } },
.Ve
.IP "help_args" 4
.IX Item "help_args"
This provides argument completion for help commands.
See the example above for how to call it.
.IP "complete_files" 4
.IX Item "complete_files"
Completes on filesystem objects (files, directories, etc).
Use either
.Sp
.Vb 1
\&  args => sub { shift\->complete_files(@_) },
.Ve
.Sp
or
.Sp
.Vb 1
\&  args => \e&complete_files,
.Ve
.Sp
Starts in the current directory.
.IP "complete_onlyfiles" 4
.IX Item "complete_onlyfiles"
Like \*(L"complete_files\*(R""
but excludes directories, device nodes, etc.
It returns regular files only.
.IP "complete_onlydirs" 4
.IX Item "complete_onlydirs"
Like \*(L"complete_files\*(R"",
but excludes files, device nodes, etc.
It returns only directories.
It \fIdoes\fR return the . and .. special directories so you'll need
to remove those manually if you don't want to see them:
.Sp
.Vb 1
\&  args = sub { grep { !/^\e.?\e.$/ } complete_onlydirs(@_) },
.Ve
.IP "history_call" 4
.IX Item "history_call"
You can use this callback to implement the standard bash
history command.  This command supports:
.Sp
.Vb 4
\&    NUM       display last N history items
\&              (displays all history if N is omitted)
\&    \-c        clear all history
\&    \-d NUM    delete an item from the history
.Ve
.Sp
Add it to your command set using something like this:
.Sp
.Vb 7
\&  "history" => { desc => "Prints the command history",
\&     doc => "Specify a number to list the last N lines of history" .
\&            "Pass \-c to clear the command history, " .
\&            "\-d NUM to delete a single item\en",
\&     args => "[\-c] [\-d] [number]",
\&     method => sub { shift\->history_call(@_) },
\&  },
.Ve
.SH "METHODS"
.IX Header "METHODS"
These are the routines that your application calls to create
and use a Term::ShellUI object.
Usually you simply call \fInew()\fR and then \fIrun()\fR \*(-- everything else
is handled automatically.
You only need to read this section if you wanted to do something out
of the ordinary.
.ie n .IP "new Term::ShellUI(\fI\fI""named args...""\fI\fR)" 4
.el .IP "new Term::ShellUI(\fI\f(CInamed args...\fI\fR)" 4
.IX Item "new Term::ShellUI(named args...)"
Creates a new ShellUI object.
.Sp
It accepts the following named parameters:
.RS 4
.IP "app" 3
.IX Item "app"
The name of this application (will be passed to \*(L"new\*(R" in Term::ReadLine).
Defaults to \f(CW$0\fR, the name of the current executable.
.IP "term" 3
.IX Item "term"
Usually Term::ShellUI uses its own Term::ReadLine object
(created with \f(CW\*(C`new Term::ReadLine $args{\*(Aqapp\*(Aq}\*(C'\fR).  However, if
you can create a new Term::ReadLine object yourself and
supply it using the term argument.
.IP "blank_repeats_cmd" 3
.IX Item "blank_repeats_cmd"
This tells Term::ShellUI what to do when the user enters a blank
line.  Pass 0 (the default) to have it do nothing (like Bash),
or 1 to have it repeat the last command (like \s-1GDB\s0).
.IP "commands" 3
.IX Item "commands"
A hashref containing all the commands that ShellUI will respond to.
The format of this data structure can be found below in the
command set documentation.
If you do not supply any commands to the constructor, you must call
the \*(L"commands\*(R" method to provide at least a minimal command set before
using many of the following calls.  You may add or delete commands or
even change the entire command set at any time.
.IP "history_file" 3
.IX Item "history_file"
If defined then the command history is saved to this file on exit.
It should probably specify a dotfile in the user's home directory.
Tilde expansion is performed, so something like
\&\f(CW\*(C`~/.myprog\-history\*(C'\fR is perfectly acceptable.
.IP "history_max = 500" 3
.IX Item "history_max = 500"
This tells how many items to save to the history file.
The default is 500.
.Sp
Note that this parameter does not affect in-memory history.  Term::ShellUI
makes no attemt to cull history so you're at the mercy
of the default of whatever ReadLine library you are using.
See \*(L"StifleHistory\*(R" in Term::ReadLine::Gnu for one way to change this.
.IP "keep_quotes" 3
.IX Item "keep_quotes"
Normally all unescaped, unnecessary quote marks are stripped.
If you specify \f(CW\*(C`keep_quotes=>1\*(C'\fR, however, they are preserved.
This is useful if your application uses quotes to delimit, say,
Perl-style strings.
.IP "backslash_continues_command" 3
.IX Item "backslash_continues_command"
Normally commands don't respect backslash continuation.  If you
pass backslash_continues_command=>1 to \*(L"new\*(R", then whenever a line
ends with a backslash, Term::ShellUI will continue reading.  The backslash
is replaced with a space, so
    $ abc \e
    > def
.Sp
Will produce the command string 'abc  def'.
.IP "prompt" 3
.IX Item "prompt"
This is the prompt that should be displayed for every request.
It can be changed at any time using the \*(L"prompt\*(R" method.
The default is <\*(L"$0 \*(R">> (see app above).
.Sp
If you specify a code reference, then the coderef is executed and
its return value is set as the prompt.  Two arguments are passed
to the coderef: the Term::ShellUI object, and the raw command.
The raw command is always "" unless you're using command completion,
where the raw command is the command line entered so far.
.Sp
For example, the following
line sets the prompt to \*(L"## > \*(R" where ## is the current number of history
items.
.Sp
.Vb 1
\&    $term\->prompt(sub { $term\->{term}\->GetHistory() . " > " });
.Ve
.Sp
If you specify an arrayref, then the first item is the normal prompt
and the second item is the prompt when the command is being continued.
For instance, this would emulate Bash's behavior ($ is the normal
prompt, but > is the prompt when continuing).
.Sp
.Vb 1
\&    $term\->prompt([\*(Aq$\*(Aq, \*(Aq>\*(Aq]);
.Ve
.Sp
Of course, you specify backslash_continues_command=>1 to to \*(L"new\*(R" to cause
commands to continue.
.Sp
And, of course, you can use an array of procs too.
.Sp
.Vb 1
\&    $term\->prompt([sub {\*(Aq$\*(Aq}, sub {\*(Aq<\*(Aq}]);
.Ve
.IP "token_chars" 3
.IX Item "token_chars"
This argument specifies the characters that should be considered
tokens all by themselves.  For instance, if I pass
token_chars=>'=', then 'ab=123' would be parsed to ('ab', '=', '123').
Without token_chars, 'ab=123' remains a single string.
.Sp
\&\s-1NOTE:\s0 you cannot change token_chars after the constructor has been
called!  The regexps that use it are compiled once (m//o).
.IP "display_summary_in_help" 3
.IX Item "display_summary_in_help"
Usually it's easier to have the command's summary (desc) printed first,
then follow it with the documentation (doc).  However, if the doc
already contains its description (for instance, if you're reading it
from a podfile), you don't want the summary up there too.  Pass 0
to prevent printing the desc above the doc.  Defaults to 1.
.RE
.RS 4
.RE
.IP "process_a_cmd([cmd])" 4
.IX Item "process_a_cmd([cmd])"
Runs the specified command or prompts for it if no arguments are supplied.
Returns the result or undef if no command was called.
.IP "\fIrun()\fR" 4
.IX Item "run()"
The main loop.  Processes all commands until someone calls
\&\f(CW\*(C`/"exit_requested(exitflag)"(true)\*(C'\fR.
.Sp
If you pass arguments, they are joined and run once.  For
instance, \f(CW$term\fR\->run(@ARGV) allows your program to be run
interactively or noninteractively:
.RS 4
.IP "myshell help" 4
.IX Item "myshell help"
Runs the help command and exits.
.IP "myshell" 4
.IX Item "myshell"
Invokes an interactive Term::ShellUI.
.RE
.RS 4
.RE
.IP "prompt(newprompt)" 4
.IX Item "prompt(newprompt)"
If supplied with an argument, this method sets the command-line prompt.
Returns the old prompt.
.IP "commands(newcmds)" 4
.IX Item "commands(newcmds)"
If supplied with an argument, it sets the current command set.
This can be used to change the command set at any time.
Returns the old command set.
.IP "add_commands(newcmds)" 4
.IX Item "add_commands(newcmds)"
Takes a command set as its first argument.
Adds all the commands in it the current command set.
It silently replaces any commands that have the same name.
.IP "exit_requested(exitflag)" 4
.IX Item "exit_requested(exitflag)"
If supplied with an argument, sets Term::ShellUI's finished flag
to the argument (1=exit, 0=don't exit).  So, to get the
interpreter to exit at the end of processing the current
command, call \f(CW\*(C`$self\->exit_requested(1)\*(C'\fR.  To cancel an exit
request before the command is finished, \f(CW\*(C`$self\->exit_requested(0)\*(C'\fR.
Returns the old state of the flag.
.IP "add_eof_exit_hook(subroutine_reference)" 4
.IX Item "add_eof_exit_hook(subroutine_reference)"
Call this method to add a subroutine as a hook into Term::ShellUI's
\&\*(L"exit on \s-1EOF\*(R" \s0(Ctrl-D) functionality. When a user enters Ctrl-D,
Term::ShellUI will call each function in this hook list, in order,
and will exit only if all of them return 0. The first function to
return a non-zero value will stop further processing of these hooks
and prevent the program from exiting.
.Sp
The return value of this method is the placement of the hook routine
in the hook list (1 is first) or 0 (zero) on failure.
.IP "get_cname(cname)" 4
.IX Item "get_cname(cname)"
This is a tiny utility function that turns the cname (array ref
of names for this command as returned by \*(L"get_deep_command\*(R") into
a human-readable string.
This function exists only to ensure that we do this consistently.
.SH "OVERRIDES"
.IX Header "OVERRIDES"
These are routines that probably already do the right thing.
If not, however, they are designed to be overridden.
.IP "\fIblank_line()\fR" 4
.IX Item "blank_line()"
This routine is called when the user inputs a blank line.
It returns a string specifying the command to run or
undef if nothing should happen.
.Sp
By default, ShellUI simply presents another command line.  Pass
\&\f(CW\*(C`blank_repeats_cmd=>1\*(C'\fR to the constructor to get ShellUI to repeat the previous
command.  Override this method to supply your own behavior.
.IP "error(msg)" 4
.IX Item "error(msg)"
Called when an error occurrs.  By default, the routine simply
prints the msg to stderr.  Override it to change this behavior.
It takes any number of arguments, cocatenates them together and
prints them to stderr.
.SH "WRITING A COMPLETION ROUTINE"
.IX Header "WRITING A COMPLETION ROUTINE"
Term::ReadLine makes writing a completion routine a
notoriously difficult task.
Term::ShellUI goes out of its way to make it as easy
as possible.  The best way to write a completion routine
is to start with one that already does something similar to
what you want (see the \*(L"\s-1CALLBACKS\*(R"\s0 section for the completion
routines that come with ShellUI).
.PP
Your routine returns an arrayref of possible completions,
a string conaining a short but helpful note,
or undef if an error prevented any completions from being generated.
Return an empty array if there are simply no applicable competions.
Be careful; the distinction between no completions and an error
can be significant.
.PP
Your routine takes two arguments: a reference to the ShellUI
object and cmpl, a data structure that contains all the information you need
to calculate the completions.  Set \f(CW$term\fR\->{debug_complete}=5
to see the contents of cmpl:
.IP "str" 3
.IX Item "str"
The exact string that needs completion.  Often, for simple completions,
you don't need anything more than this.
.Sp
\&\s-1NOTE:\s0 str does \fInot\fR respect token_chars!  It is supplied unchanged
from Readline and so uses whatever tokenizing it implements.
Unfortunately, if you've changed token_chars, this will often
be different from how Term::ShellUI would tokenize the same string.
.IP "cset" 3
.IX Item "cset"
Command set for the deepest command found (see \*(L"get_deep_command\*(R").
If no command was found then cset is set to the topmost command
set ($self\->\fIcommands()\fR).
.IP "cmd" 3
.IX Item "cmd"
The command hash for deepest command found or
undef if no command was found (see \*(L"get_deep_command\*(R").
cset is the command set that contains cmd.
.IP "cname" 3
.IX Item "cname"
The full name of deepest command found as an array of tokens
(see \*(L"get_deep_command\*(R").  Use \*(L"get_cname\*(R" to convert
this into a human-readable string.
.IP "args" 3
.IX Item "args"
The arguments (as a list of tokens) that should be passed to the command
(see \*(L"get_deep_command\*(R").  Valid only if cmd is non-null.  Undef if no
args were passed.
.IP "argno" 3
.IX Item "argno"
The index of the argument (in args) containing the cursor.
If the user is trying to complete on the command name, then
argno is negative (because the cursor comes before the arguments).
.IP "tokens" 3
.IX Item "tokens"
The tokenized command-line.
.IP "tokno" 3
.IX Item "tokno"
The index of the token containing the cursor.
.IP "tokoff" 3
.IX Item "tokoff"
The character offset of the cursor in the token.
.Sp
For instance, if the cursor is on the first character of the
third token, tokno will be 2 and tokoff will be 0.
.IP "twice" 3
.IX Item "twice"
True if user has hit tab twice in a row.  This usually means that you
should print a message explaining the possible completions.
.Sp
If you return your completions as a list, then \f(CW$twice\fR is handled
for you automatically.  You could use it, for instance, to display
an error message (using completemsg) telling why no completions
could be found.
.IP "rawline" 3
.IX Item "rawline"
The command line as a string, exactly as entered by the user.
.IP "rawstart" 3
.IX Item "rawstart"
The character position of the cursor in rawline.
.PP
The following are utility routines that your completion function
can call.
.IP "completemsg(msg)" 4
.IX Item "completemsg(msg)"
Allows your completion routine to print to the screen while completing
(i.e. to offer suggestions or print debugging info \*(-- see debug_complete).
If it just blindly calls print, the prompt will be corrupted and things
will be confusing until the user redraws the screen (probably by hitting
Control-L).
.Sp
.Vb 1
\&    $self\->completemsg("You cannot complete here!\en");
.Ve
.Sp
Note that Term::ReadLine::Perl doesn't support this so the user will always
have to hit Control-L after printing.  If your completion routine returns
a string rather than calling \fIcompletemsg()\fR then it should work everywhere.
.IP "\fIsuppress_completion_append_character()\fR" 4
.IX Item "suppress_completion_append_character()"
When the ReadLine library finds a unique match among the list that
you returned, it automatically appends a space.  Normally this is
what you want (i.e. when completing a command name, in help, etc.)
However, if you're navigating the filesystem, this is definitely
not desirable (picture having to hit backspace after completing
each directory).
.Sp
Your completion function needs to call this routine every time it
runs if it doesn't want a space automatically appended to the
completions that it returns.
.IP "\fIsuppress_completion_escape()\fR" 4
.IX Item "suppress_completion_escape()"
Normally everything returned by your completion routine
is escaped so that it doesn't get destroyed by shell metacharacter
interpretation (quotes, backslashes, etc).  To avoid escaping
twice (disastrous), a completion routine that does its own escaping
(perhaps using Text::Shellwords::Cursorparse_escape)
must call suppress_completion_escape every time is called.
.IP "force_to_string(cmpl, commmpletions, default_quote)" 4
.IX Item "force_to_string(cmpl, commmpletions, default_quote)"
If all the completions returned by your completion routine should be
enclosed in single or double quotes, call force_to_string on them.
You will most likely need this routine if keep_quotes is 1.
This is useful when completing a construct that you know must
always be quoted.
.Sp
force_to_string surrounds all completions with the quotes supplied by the user
or, if the user didn't supply any quotes, the quote passed in default_quote.
If the programmer didn't supply a default_quote and the user didn't start
the token with an open quote, then force_to_string won't change anything.
.Sp
Here's how to use it to force strings on two possible completions,
aaa and bbb.  If the user doesn't supply any quotes, the completions
will be surrounded by double quotes.
.Sp
.Vb 1
\&     args => sub { shift\->force_to_string(@_,[\*(Aqaaa\*(Aq,\*(Aqbbb\*(Aq],\*(Aq"\*(Aq) },
.Ve
.Sp
Calling force_to_string escapes your completions (unless your callback
calls suppress_completion_escape itself), then calls
suppress_completion_escape to ensure the final quote isn't mangled.
.SH "INTERNALS"
.IX Header "INTERNALS"
These commands are internal to ShellUI.
They are documented here only for completeness \*(-- you
should never need to call them.
.IP "get_deep_command" 4
.IX Item "get_deep_command"
Looks up the supplied command line in a command hash.
Follows all synonyms and subcommands.
Returns undef if the command could not be found.
.Sp
.Vb 2
\&    my($cset, $cmd, $cname, $args) =
\&        $self\->get_deep_command($self\->commands(), $tokens);
.Ve
.Sp
This call takes two arguments:
.RS 4
.IP "cset" 3
.IX Item "cset"
This is the command set to use.  Pass \f(CW$self\fR\->\fIcommands()\fR
unless you know exactly what you're doing.
.IP "tokens" 3
.IX Item "tokens"
This is the command line that the command should be read from.
It is a reference to an array that has already been split
on whitespace using Text::Shellwords::Cursor::parse_line.
.RE
.RS 4
.Sp
and it returns a list of 4 values:
.IP "1." 3
cset: the deepest command set found.  Always returned.
.IP "2." 3
cmd: the command hash for the command.  Undef if no command was found.
.IP "3." 3
cname: the full name of the command.  This is an array of tokens,
i.e. ('show', 'info').  Returns as deep as it could find commands
even if the final command was not found.
.IP "4." 3
args: the command's arguments (all remaining tokens after the
command is found).
.RE
.RS 4
.RE
.IP "get_cset_completions(cset)" 4
.IX Item "get_cset_completions(cset)"
Returns a list of commands from the passed command set that are suitable
for completing.
.IP "call_args" 4
.IX Item "call_args"
Given a command set, does the correct thing at this stage in the
completion (a surprisingly nontrivial task thanks to ShellUI's
flexibility).  Called by \fIcomplete()\fR.
.IP "complete" 4
.IX Item "complete"
This routine figures out the command set of the completion routine
that needs to be called, then calls \fIcall_args()\fR.  It is called
by completion_function.
.Sp
You should override this routine if your application has custom
completion needs (like non-trivial tokenizing, where you'll need
to modify the cmpl data structure).  If you override
this routine, you will probably need to override
call_cmd as well.
.IP "completion_function" 4
.IX Item "completion_function"
This is the entrypoint to the ReadLine completion callback.
It sets up a bunch of data, then calls complete to calculate
the actual completion.
.Sp
To watch and debug the completion process, you can set \f(CW$self\fR\->{debug_complete}
to 2 (print tokenizing), 3 (print tokenizing and results) or 4 (print
everything including the cmpl data structure).
.Sp
Youu should never need to call or override this function.  If
you do (but, trust me, you don't), set
\&\f(CW$self\fR\->{term}\->Attribs\->{completion_function} to point to your own
routine.
.Sp
See the Term::ReadLine documentation for a description of the arguments.
.IP "get_cmd_summary(tokens, cset)" 4
.IX Item "get_cmd_summary(tokens, cset)"
Prints a one-line summary for the given command.
Uses self\->\fIcommands()\fR if cset is not specified.
.IP "get_cmd_help(tokens, cset)" 4
.IX Item "get_cmd_help(tokens, cset)"
Prints the full help text for the given command.
Uses self\->\fIcommands()\fR if cset is not specified.
.IP "get_category_summary(name, cats)" 4
.IX Item "get_category_summary(name, cats)"
Prints a one-line summary for the named category
in the category hash specified in cats.
.IP "get_category_help(cat, cset)" 4
.IX Item "get_category_help(cat, cset)"
Returns a summary of the commands listed in cat.
You must pass the command set that contains those commands in cset.
.IP "get_all_cmd_summaries(cset)" 4
.IX Item "get_all_cmd_summaries(cset)"
Pass it a command set, and it will return a string containing
the summaries for each command in the set.
.IP "\fIload_history()\fR" 4
.IX Item "load_history()"
If \f(CW$self\fR\->{history_file} is set (see \*(L"new\*(R"), this will load all
history from that file.  Called by run on startup.  If you
don't use run, you will need to call this command manually.
.IP "\fIsave_history()\fR" 4
.IX Item "save_history()"
If \f(CW$self\fR\->{history_file} is set (see \*(L"new\*(R"), this will save all
history to that file.  Called by run on shutdown.  If you
don't use run, you will need to call this command manually.
.Sp
The history routines don't use ReadHistory and WriteHistory so they
can be used even if other ReadLine libs are being used.  save_history
requires that the ReadLine lib supply a GetHistory call.
.IP "call_command(parms)" 4
.IX Item "call_command(parms)"
Executes a command and returns the result.  It takes a single
argument: the parms data structure.
.Sp
parms is a subset of the cmpl data structure (see the \*(L"complete(cmpl)\*(R" in complete
routine for more).  Briefly, it contains:
cset, cmd, cname, args (see \*(L"get_deep_command\*(R"),
tokens and rawline (the tokenized and untokenized command lines).
See complete for full descriptions of these fields.
.Sp
This call should be overridden if you have exotic command
processing needs.  If you override this routine, you will probably
need to override the complete routine too.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2003\-2011 Scott Bronson, all rights reserved.
This program is free software released under the \s-1MIT\s0 license.
.SH "AUTHORS"
.IX Header "AUTHORS"
Scott Bronson <bronson@rinspin.com>
Lester Hightower <hightowe@cpan.org>
Ryan Gies <ryan@livesite.net>
Martin Kluge <mk@elxsi.de>
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 866:" 4
.IX Item "Around line 866:"
alternative text '/\*(L"exit_requested(exitflag)\*(R"' contains non-escaped | or /
