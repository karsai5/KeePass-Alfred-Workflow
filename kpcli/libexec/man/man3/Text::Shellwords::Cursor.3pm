.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Shellwords::Cursor 3"
.TH Text::Shellwords::Cursor 3 "2012-02-03" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Shellwords::Cursor \- Parse a string into tokens
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use Text::Shellwords::Cursor;
\& my $parser = Text::Shellwords::Cursor\->new();
\& my $str = \*(Aqab cdef "ghi"    j"k\e"l "\*(Aq;
\& my ($tok1) = $parser\->parse_line($str);
\&   $tok1 = [\*(Aqab\*(Aq, \*(Aqcdef\*(Aq, \*(Aqghi\*(Aq, \*(Aqj\*(Aq, \*(Aqk"l \*(Aq]
\& my ($tok2, $tokno, $tokoff) = $parser\->parse_line($str, cursorpos => 6);
\&    as above, but $tokno=1, $tokoff=3  (under the \*(Aqf\*(Aq)
.Ve
.PP
\&\s-1DESCRIPTION\s0
.PP
This module is very similar to Text::Shellwords and Text::ParseWords.
However, it has one very significant difference: it keeps track of
a character position in the line it's parsing.  For instance, if you
pass it (\*(L"zq fmgb\*(R", cursorpos=>6), it would return
(['zq', 'fmgb'], 1, 3).  The cursorpos parameter
tells where in the input string the cursor resides
(just before the 'b'), and the result tells you that
the cursor was on token 1 ('fmgb'), character 3 ('b').
This is very useful when computing command-line completions
involving quoting, escaping, and tokenizing characters (like '(' or '=').
.PP
A few helper utilities are included as well.  You can escape a string to
ensure that parsing it will produce the original string (parse_escape).
You can also reassemble the tokens with a visually pleasing amount of
whitespace between them (join_line).
.PP
This module started out as an integral part of Term::GDBUI using
code loosely based on Text::ParseWords.  However,
it is now basically a ground-up reimplementation.  It was
split out of Term::GDBUI for version 0.8.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 3
.IX Item "new"
Creates a new parser.  Takes named arguments on the command line.
.RS 3
.IP "keep_quotes" 4
.IX Item "keep_quotes"
Normally all unescaped, unnecessary quote marks are stripped.
If you specify \f(CW\*(C`keep_quotes=>1\*(C'\fR, however, they are preserved.
This is useful if you need to know whether the string was quoted
or not (string constants) or what type of quotes was around it
(affecting variable interpolation, for instance).
.IP "token_chars" 4
.IX Item "token_chars"
This argument specifies the characters that should be considered
tokens all by themselves.  For instance, if I pass
token_chars=>'=', then 'ab=123' would be parsed to ('ab', '=', '123').
Without token_chars, 'ab=123' remains a single string.
.Sp
\&\s-1NOTE:\s0 you cannot change token_chars after the constructor has been
called!  The regexps that use it are compiled once (m//o).
Also, until the Gnu Readline library can accept \*(L"=[],\*(R" without
diving into an endless loop, we will not tell history expansion
to use token_chars (it uses \*(L" \et\\fIen()\fR<>;&|\*(R" by default).
.IP "debug" 4
.IX Item "debug"
Turns on rather copious debugging to try to show what the parser is
thinking at every step.
.IP "space_none" 4
.IX Item "space_none"
.PD 0
.IP "space_before" 4
.IX Item "space_before"
.IP "space_after" 4
.IX Item "space_after"
.PD
These variables affect how whitespace in the line is normalized and
it is reassembled into a string.  See the join_line routine.
.IP "error" 4
.IX Item "error"
This is a reference to a routine that should be called to display
a parse error.  The routine takes two arguments: a reference to the
parser, and the error message to display as a string.
.IP "parsebail(msg)" 4
.IX Item "parsebail(msg)"
If the parsel routine or any of its subroutines runs into a fatal
error, they call parsebail to present a very descriptive diagnostic.
.IP "parsel" 4
.IX Item "parsel"
This is the heinous routine that actually does the parsing.
You should never need to call it directly.  Call
parse_line
instead.
.IP "parse_line(line, \fInamed args\fR)" 4
.IX Item "parse_line(line, named args)"
This is the entrypoint to this module's parsing functionality.  It converts
a line into tokens, respecting quoted text, escaped characters,
etc.  It also keeps track of a cursor position on the input text,
returning the token number and offset within the token where that position
can be found in the output.
.Sp
This routine originally bore some resemblance to Text::ParseWords.
It has changed almost completely, however, to support keeping track
of the cursor position.  It also has nicer failure modes, modular
quoting, token characters (see token_chars in \*(L"new\*(R"), etc.  This
routine now does much more.
.Sp
Arguments:
.RS 4
.IP "line" 3
.IX Item "line"
This is a string containing the command-line to parse.
.RE
.RS 4
.Sp
This routine also accepts the following named parameters:
.IP "cursorpos" 3
.IX Item "cursorpos"
This is the character position in the line to keep track of.
Pass undef (by not specifying it) or the empty string to have
the line processed with cursorpos ignored.
.Sp
Note that passing undef is \fInot\fR the same as passing
some random number and ignoring the result!  For instance, if you
pass 0 and the line begins with whitespace, you'll get a 0\-length token at
the beginning of the line to represent the cursor in
the middle of the whitespace.  This allows command completion
to work even when the cursor is not near any tokens.
If you pass undef, all whitespace at the beginning and end of
the line will be trimmed as you would expect.
.Sp
If it is ambiguous whether the cursor should belong to the previous
token or to the following one (i.e. if it's between two quoted
strings, say \*(L"a\*(R"\*(L"b\*(R" or a token_char), it always gravitates to
the previous token.  This makes more sense when completing.
.IP "fixclosequote" 3
.IX Item "fixclosequote"
Sometimes you want to try to recover from a missing close quote
(for instance, when calculating completions), but usually you
want a missing close quote to be a fatal error.  fixclosequote=>1
will implicitly insert the correct quote if it's missing.
fixclosequote=>0 is the default.
.IP "messages" 3
.IX Item "messages"
parse_line is capable of printing very informative error messages.
However, sometimes you don't care enough to print a message (like
when calculating completions).  Messages are printed by default,
so pass messages=>0 to turn them off.
.RE
.RS 4
.Sp
This function returns a reference to an array containing three
items:
.IP "tokens" 3
.IX Item "tokens"
A the tokens that the line was separated into (ref to an array of strings).
.IP "tokno" 3
.IX Item "tokno"
The number of the token (index into the previous array) that contains
cursorpos.
.IP "tokoff" 3
.IX Item "tokoff"
The character offet into tokno of cursorpos.
.RE
.RS 4
.Sp
If the cursor is at the end of the token, tokoff will point to 1
character past the last character in tokno, a non-existant character.
If the cursor is between tokens (surrounded by whitespace), a zero-length
token will be created for it.
.RE
.IP "parse_escape(lines)" 4
.IX Item "parse_escape(lines)"
Escapes characters that would be otherwise interpreted by the parser.
Will accept either a single string or an arrayref of strings (which
will be modified in-place).
.IP "join_line(tokens)" 4
.IX Item "join_line(tokens)"
This routine does a somewhat intelligent job of joining tokens
back into a command line.  If token_chars (see \*(L"new\*(R") is empty
(the default), then it just escapes backslashes and quotes, and
joins the tokens with spaces.
.Sp
However, if token_chars is nonempty, it tries to insert a visually
pleasing amount of space between the tokens.  For instance, rather
than 'a ( b , c )', it tries to produce 'a (b, c)'.  It won't reformat
any tokens that aren't found in \f(CW$self\fR\->{token_chars}, of course.
.Sp
To change the formatting, you can redefine the variables
\&\f(CW$self\fR\->{space_none}, \f(CW$self\fR\->{space_before}, and \f(CW$self\fR\->{space_after}.
Each variable is a string containing all characters that should
not be surrounded by whitespace, should have whitespace before,
and should have whitespace after, respectively.  Any character
found in token_chars, but non in any of these space_ variables,
will have space placed both before and after.
.RE
.RS 3
.RE
.SH "BUGS"
.IX Header "BUGS"
None known.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2003\-2011 Scott Bronson, all rights reserved.
This program is covered by the \s-1MIT\s0 license.
.SH "AUTHOR"
.IX Header "AUTHOR"
Scott Bronson <bronson@rinspin.com>
